replicaCount: 1

ordinals:

  enabled: false
  start: 0

image:

  repository: atlassian/confluence
  pullPolicy: IfNotPresent
  tag: ""

serviceAccount:

  create: true
  name:
  imagePullSecrets: []
  annotations: {}

  role:
    create: true
  clusterRole:
    create: false
    name:
  roleBinding:
    create: true
  clusterRoleBinding:
    create: false
    name:

database:

  type: postgresql
  url: 'jdbc:postgresql://pgatlaciandb-ha.confluence.svc.cluster.local:5432/confluence_db'
  credentials:

    # 'kubectl create secret generic <secret-name> --from-literal=username=<username> --from-literal=password=<password>'
    secretName: confluence-db
    usernameSecretKey: username
    passwordSecretKey: password

volumes:
  localHome:
    persistentVolumeClaim:
      create: true
      storageClassName: local-path
      resources:
        requests:
          storage: 1Gi

    persistentVolumeClaimRetentionPolicy:
      whenDeleted:
      whenScaled:

    customVolume: {}
    # persistentVolumeClaim:
    #   claimName: "<pvc>"

    mountPath: "/var/atlassian/application-data/confluence"

  sharedHome:
    persistentVolumeClaim:
      create: true
      storageClassName: local-path
      resources:
        requests:
          storage: 1Gi

    customVolume: {}
    # persistentVolumeClaim:
    #   claimName: "<pvc>"

    mountPath: "/var/atlassian/application-data/shared-home"
    subPath:

    # Modify permissions on shared-home
    nfsPermissionFixer:
      enabled: true
      mountPath: "/shared-home"
      imageRepo: alpine
      imageTag: latest
      command:

  synchronyHome:

    persistentVolumeClaim:
      create: true
      storageClassName: local-path
      resources:
        requests:
          storage: 1Gi

    persistentVolumeClaimRetentionPolicy:

      whenDeleted:
      whenScaled:

    customVolume: { }
    # persistentVolumeClaim:
    #   claimName: "<pvc>"

    mountPath: "/var/atlassian/application-data/confluence"

  additional: []
  additionalSynchrony: []
  defaultPermissionsMode: 484


ingress:

  create: false
  openShiftRoute: false
  routeHttpHeaders: {}
  className: "nginx"
  nginx: true
  maxBodySize: 250m
  proxyConnectTimeout: 60
  proxyReadTimeout: 60
  proxySendTimeout: 60

  host:

  path:

  annotations: {}

  https: true

  tlsSecretName:

# Confluence configuration
confluence:

  useHelmReleaseNameAsContainerName: false

  service:
    port: 80
    type: ClusterIP
    sessionAffinity: None
    sessionAffinityConfig:
      clientIP:
        timeoutSeconds:
    loadBalancerIP:

    contextPath:
    annotations: {}

  hazelcastService:
    enabled: false
    port: 5701
    type: ClusterIP
    annotations: {}

  securityContextEnabled: true
  securityContext:

    fsGroup: 2002
  containerSecurityContext: {}

  umask: "0022"

  setPermissions: true

  ports:
    http: 8090
    hazelcast: 5701

  # Confluence licensing details
  #
  license:

    # 'kubectl create secret generic <secret-name> --from-literal=license-key=<license>
    secretName:

    # -- The key in the K8s Secret that contains the Confluence license key
    secretKey: license-key

  readinessProbe:
    enabled: true
    initialDelaySeconds: 10
    periodSeconds: 5
    timeoutSeconds: 1
    failureThreshold: 6
    customProbe: {}

  startupProbe:

    # -- Whether to apply the startupProbe check to pod.
    #
    enabled: false

    # -- Time to wait before starting the first probe
    #
    initialDelaySeconds: 60

    # -- How often (in seconds) the Confluence container startup probe will run
    #
    periodSeconds: 5

    failureThreshold: 120

  livenessProbe:
    enabled: false
    initialDelaySeconds: 60
    periodSeconds: 5
    timeoutSeconds: 1
    failureThreshold: 12
    customProbe: {}

  # Confluence log configuration
  accessLog:
    enabled: true
    mountPath: "/opt/atlassian/confluence/logs"
    localHomeSubPath: "logs"

  # Data Center clustering
  #
  clustering:
    enabled: true
    usePodNameAsClusterNodeName: true

  # Use AWS S3 to store attachments. From Confluence 8.1 onwards.
  #

  s3AttachmentsStorage:

    bucketName:
    bucketRegion:
    endpointOverride:

  # Confluence Pod resource requests
  #
  resources:

    jvm:
      maxHeap: "1g"
      minHeap: "1g"
      reservedCodeCache: "256m"
    container:

      requests:
        cpu: "250m"
        memory: "1G"

  shutdown:

    terminationGracePeriodSeconds: 25
    command: "/shutdown-wait.sh"

  postStart:
    command:

  forceConfigUpdate: false
  additionalJvmArgs: []
  tomcatConfig:

    generateByHelm: false

    mgmtPort: "8000"
    port: "8090"
    maxThreads: "100"
    minSpareThreads: "10"
    connectionTimeout: "20000"
    enableLookups: "false"
    protocol: "org.apache.coyote.http11.Http11NioProtocol"
    redirectPort: "8443"
    acceptCount: "10"
    debug: "0"
    uriEncoding: "UTF-8"
    # secure is retrieved from ingress.https value
    secure:
    # scheme is set depending on ingress.https value (http if false, https if true)
    scheme:
    # proxyName is retrieved from ingress.host value
    proxyName:
    # proxyPort is set depending on ingress.https value (80 if http, 443 if https)
    proxyPort:
    maxHttpHeaderSize: "8192"
    proxyInternalIps:
    trustedProxies:

    # -- Custom server.xml to be mounted into /opt/atlassian/confluence/conf
    #
    customServerXml: |
  seraphConfig:
    generateByHelm: false

    autoLoginCookieAge: "1209600"
  additionalLibraries: []
  additionalBundledPlugins: []
  additionalVolumeMounts: []
  additionalEnvironmentVariables: []
  additionalPorts: []
  additionalVolumeClaimTemplates: []
  topologySpreadConstraints: []
  jvmDebug:
    enabled: false
  additionalCertificates:
    secretName:
    customCmd:

# Monitoring
#
monitoring:

  exposeJmxMetrics: false
  jmxExporterInitContainer:
    runAsRoot: true
    customSecurityContext: {}
    resources: {}
  jmxServiceAnnotations: {}
  fetchJmxExporterJar: true
  jmxExporterImageRepo: bitnami/jmx-exporter
  jmxExporterImageTag: 0.18.0
  jmxExporterPort: 9999
  jmxExporterPortType: ClusterIP
  jmxExporterCustomJarLocation:
  jmxExporterCustomConfig: {}
  #  rules:
  #   - pattern: ".*"

  serviceMonitor:
    create: false
    prometheusLabelSelector: {}
      # release: prometheus

    scrapeIntervalSeconds: 30

  grafana:
    createDashboards: false
    dashboardLabels: {}
    dashboardAnnotations: {}
      # k8s-sidecar-target-directory: /tmp/dashboards/example-folder

# Confluence Synchrony configuration
# https://confluence.atlassian.com/doc/configuring-synchrony-858772125.html
synchrony:

  enabled: true

  replicaCount: 1

  podAnnotations: {}
  service:
    port: 80
    type: ClusterIP
    loadBalancerIP:
    annotations: {}

  securityContextEnabled: true

  securityContext:
    fsGroup: 2002
  containerSecurityContext: {}
  setPermissions: true

  # Port definitions
  #
  ports:
    http: 8091
    hazelcast: 5701
  readinessProbe:
    healthcheckPath: "/synchrony/heartbeat"
    initialDelaySeconds: 5
    periodSeconds: 1
    failureThreshold: 10

  # Synchrony Pod resource requests
  #
  resources:
    jvm:
      minHeap: "1g"
      maxHeap: "2g"
      stackSize: "2048k"

    container:
      requests:

        cpu: "250m"
        memory: "1G"
 
  additionalJvmArgs: []
    #- -Dsynchrony.example.system.property=46

  shutdown:
    terminationGracePeriodSeconds: 25

  additionalLibraries: []

  additionalVolumeMounts: []

  additionalPorts: []

  topologySpreadConstraints: []

  additionalCertificates:
    secretName:
    customCmd:

# Fluentd configuration

fluentd:

  enabled: false
  imageRepo: fluent/fluentd-kubernetes-daemonset
  imageTag: v1.11.5-debian-elasticsearch7-1.2
  resources: {}
  command:
  customConfigFile: false
  fluentdCustomConfig: {}

  httpPort: 9880

  # Elasticsearch config based on your ELK stack
  #
  elasticsearch:
    enabled: true
    hostname: elasticsearch
    indexNamePrefix: confluence

  extraVolumes: []

podAnnotations: {}
#  name: <value>

podLabels: {}
#  name: <value>

nodeSelector: {}
#  name: <value>

tolerations: []

affinity: {}

schedulerName:

priorityClassName:

additionalContainers: []

additionalInitContainers: []

additionalLabels: {}

additionalFiles: []

additionalHosts: []

podDisruptionBudget:
  enabled: false
  labels: {}
  annotations: {}
  minAvailable:
  maxUnavailable:

additionalConfigMaps: []

atlassianAnalyticsAndSupport:

  analytics:
    enabled: true

  helmValues:
    enabled: true

testPods:
  resources: {}
  labels: {}
  annotations: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
  schedulerName:
  image:
    permissionsTestContainer: debian:stable-slim
    statusTestContainer: alpine:latest

openshift:

  runWithRestrictedSCC: false


opensearch:
  enabled: false

  credentials:
    createSecret: true
    existingSecretRef:
      name:
  singleNode: true
  resources:
    requests:
      cpu: 1
      memory: 1Gi
  persistence:
    size: 10Gi
  extraEnvs:
    - name: plugins.security.ssl.http.enabled
      value: "false"
  envFrom:
    - secretRef:
         name: opensearch-initial-password
